#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>


//=====================================================================================================================================
//操作符详解
//算术操作符
//移位操作符
//位操作符
//赋值操作符
//单目操作符
//关系操作符
//逻辑操作符
//条件操作符
//逗号操作符
//下标引用，函数调用和结构成员

//==================================================================================================================================

//算术操作符 + - * / %
//1.除了%操作符之外，其他的几个操作符可以用作整数和浮点数
//2.对于/操作符如果两位操作数都为整数，执行整数除法。而只要是浮点执行数执行的就是浮点数除法

//int和int型的数据操作，得到的结果肯定是整数型的，所以小数部分直接去掉了，就算用% f去输出，也不会是正确的结果。
//例如：
//
//int a = 5, b = 3;
//
//float c;
//
//c  = a / b;  // 输出结果为1.0
//若想要输出浮点型 两个操作数必须要有一个为浮点型 如 5/2.0 = 2.500000 

//3.%操作符的两位操作数必须是整数。返回的是整除后的余数

//========================================================================================================================================
 
//移位操作符    ----->  移动的是二进制位      //只能操作整数
//
//左移操作符 <<
//右移操作符 >>
//
//左移操作符的移位规则 左边抛弃，右边补0

//
//int main()
//{
//	int a = 16;               // 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0001 0000  ---->16 
//	printf("%d\n",a);
//	int b = a >> 1;          //右移操作符；（1，算术右移： 右边丢弃，左边补原符号位
//								//2，逻辑右移：右边丢弃，左边补0
//	printf("%d\n",b);		// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 1000 --->8  所以这个编译器选择的是算术右移
//
//
//	int c = 5;				//整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0101  ----> 5
//	printf("%d", c);				//2，逻辑右移：右边丢弃，左边补0
//	int d = c << 1;         //整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 1010  -----> 10
//	printf("%d",d);
//
//	return 0;         //警告 对于移动运算符，不要移动复数位，这是标准未定义的
//}

//======================================================================================================================================

//  & --->按位与 
//  | --->按位或
//  ^ --->按位异或

//		操作数必须是整数 

//int main()
//{
//	int a = 3;
//	int b = 5;
//	// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0011
//	// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0101
//
//	int c = a & b;
//	int d = a | b;
//	int e = a ^ b;
//	printf("c=%d\n",c);
//	// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0001   --->1
//	
//	printf("d=%d\n",d);
//	// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0111 ---->7
//	
//	printf("e=%d\n",e);
//	// 整型4个字节 32个比特位 0000 0000 0000 0000 0000 0000 0000 0110 --->6
//
//	//若为负数则就要进行补码运算
//
//	return 0;
//
//}

//================================================================================================================================


//int main()     //不创建新变量交换新的临时变量  缺陷 整数值 相加溢出就没了
//{
//	int a = 3;
//	int b = 5;
//	int c = 3;
//	int d = 5;
//
////方法1； 整数值 相加值 溢出就没了
//	printf("%d,%d\n", a, b);
//
//	a = a + b;
//	b = a - b;
//
//	a = a - b;
//	printf("%d,%d\n",a,b);
//
//
//	//方法2；  异或法  但是可读性差 运算速度慢
//
//	printf("%d,%d\n", c, d);
//
//	c = c ^ d;    //011^101 ---> 110
//	d = c ^ d;    //110^101 ---> 011 
//	c = c ^ d;    //110^011 ---> 101 
//	
//	printf("%d,%d\n", c, d);
//
//	return 0;
//
//}

//=====================================================================================================================================

//编写代码实现：一个整形数存储在内存中的二进制中的1的个数

//int main() 
//{
//
//	int num = 0;
//	int count = 0;
//
//	scanf("%d",&num);          
//	//统计num的补码中的有几个1
//	while (num)                     //有问题 算负数有问题
//	{
//		if (num % 2 == 1)
//			count++;
//		num = num / 2;
//	}
//	printf("%d", count);
//	return 0;
//
//}


//int main()             //按位 & 来求二进制位 
//{
//	int num = 0;
//	int count = 0;
//	int i = 0;
//
//	scanf("%d", &num);
//	for (i = 0; i < 32; i++)
//	{
//		int u = num >> i;
//		if ((u&1) == 1)
//			count++;
//	}
//	printf("%d", count);
//	return 0;
//}

//=================================================================================================================================

//赋值操作符  =              //注意区别 == 判断符号

//int main()
//{
//	int a = 10;
//	int x = 20;
//	int y = 20;
//	a = x = y + 1;			//连续赋值  但不推荐
//	
//	
//	printf("%d",a);
//	return 0;
//
//}

//=========================================================================================================================================

////sizeof --------> 操作数的类型长度（按字节为单位）
//int main()
//{
//
//	short s = 0;
//	int y ;
//
//	printf("%d\n",sizeof( s = y+5));   //加完放s   结果的类型都是 s 说了算
//	printf("%d\n", s);   //sizeof(表达式) 表达式的内容不会发生真实的运算 
//	return 0;
//}

//============================================================================================================================

////  ' ~ '  ----->按位取反
//int main()
//{
//	int a = 0;        //  0000 0000 
//	printf("%d\n", ~a); //1111 1111
//
//	return 0;
//}

//===================================================================================================================================

////++
////--
//
//int main()
//
//{
//	int a = 10;
//	printf("%d\n",++a);   //前置++           先++ 再使用
//	printf("%d\n", a++);  //后置++            先使用后++
//
//	return 0;
//}
//

//==============================================================================================================================

//  ' * ' ----->间接访问操作符（解引用操作符） 
//   (类型)  ------> 强制类型转换


//关系操作符
//逻辑操作符
// &&  逻辑与         假如 左边逻辑为 0  右边逻辑不运算了
//  || 逻辑或
 
////
//int main()
//{
//	int i = 0, a = 1, b = 1, c = 2, d = 3;
//	//  i = a++  &&  ++b  &&  d++;         //左边逻辑为0时 右边逻辑不再运算 
//	
//	// i = a++ || ++b || d++;              //当左边逻辑为1时 右边的逻辑不再运算
//	printf("%d %d %d %d",a,b,c,d);     //故输出为 1 1 2 3
//
//	
//
//	return 0;
//}

//=======================================================================================================================================
//  条件操作符  EPX1 ? EXP2 : EXP3

//int main()
//{
//	int a = 0;
//	int b = 0;
//	if (a > 5)
//		b = 3;
//	else
//	b = -3;
//	printf("%d\n",b);
//
//
//	b = a > 5 ? 3 : -3;  //a大于5吗？ 是b输出3 否则b输出-3 ；
//	printf("%d\n",b);
//	return 0;
//}


//========================================================================================================================================

//逗号表达式  就是用逗号隔开的多个表达式，逗号表达式，从左到右依次执行。整个表达式的结果是最后表达式的结果


//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);  
//	printf("%d",c);
//
//	if (a=b+1,c=a/2, b>0)
//
//	return 0;
//}

//=======================================================================================================================================
////下标引用、函数调用 和 结构成员
//struct stu    //创建一个结构体变量
//{
//	char name[20];
//	int age;
//	char id[20];
//};                       //注意分号 
//
//int main()
//{
//	int a[10] = { 0 };  // []下标停用操作符 
//	a[4] = 10;			//一个数组名 一个索引值
//
//	struct stu s1 = { "lqenen",22,"天文爱好者" }; //使用struct stu 这个对象s1 并初始化
//	struct stu* ps = &s1;               //对s1取地址 用指针变量存放
//
//	printf("%s\n",(*ps).name);         //(解引用后.成员名)
//	//或者
//	printf("%s\n",ps -> name)  // 利用结构体指针操作符   { 结构体指针 -> 成员名  }
//
//
//	printf("%s\n", s1.name);    // 结构体变量.成员名
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id);
//
//	return 0;
//}

//=====================================================================================================================================

//表达式求值

//隐式类型转换 



//C的整型算术运算总是至少以缺省整型类型的精度来进行的 为了获得这个精度，表达式中的字符和短整型操作数
//在使用之前就被转换为普通整型，成为整型提升
//
//int main()
//{
//	char a = 3;
//	//00000011  ---->a 
//	//
//	char b = 127;
//	//‭01111111‬  ----->b
//	char c = a + b; //char 类型是一个字节 8个比特位 就溢出截断再存储
//	//a整型提升 ：按照符号类型的符号位来提升的
//	//有符号的a 高位0 提升时高位为0
//	//a ----> 00000000 00000000 00000000 00000011 
//	//b ----> 00000000 00000000 00000000 ‭01111111‬
//	//相加c-> 00000000 00000000 00000000 10000010 截断放 c ---> 1000 0010
//	//原高位变成了 1 表示负数 取原码 减一取反              补码 1000 0001 
//	//													   原码 1111 1110   --->  -126
//	printf("c = %d\n",c);
//
//
//
//
//	char e = 0xb9;             //运算时发生整型提升的例子 1011 1001  ---> 11111111 11111111 11111111 10111001
//	if (e == 0xb9)             // 11111111 11111111 11111111 10111001  不等于   00000000 00000000 00000000 10111001
//		printf("e = %d\n", e);
//	else
//		printf("e发生提升 符号位为1 前补1 不与0xb9 相等了\n");
//
//	char d = 1;
//	printf("sizeof( d) = %u\n", sizeof(d));
//	printf("sizeof(+d) = %u\n", sizeof(+d));   //发生了运算就产生了整型提升 为 int 四个字节 
//	printf("sizeof(!d) = %u\n", sizeof(!d));   //按位取反
//
//
//	return 0;
//}


//========================================================================================================================================

//算术类型装换


//操作符的属性  1，操作符的优先级 2，操作符的结合性  3，是否控制求值顺序

//======================================================================================================================================================
//======================================================================================================================================================


//指针详解

//指针是什么  指针就是变量 用来存放地址的 地址是位一标示一块地址空间的
//指针的大小在32位平台是4个字节 在64位是8个字节


//指针和指针类型
//指针类型 决定了 指针解引用 操作时的大小  比如：char*解引用操作只能访问一个字节 而 int*的指针 可以访问 四个字节

//指针加减整数
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a; 
//	printf("%p\n",pa);        //
//	printf("%p\n", pa+1);		//指针+整数 表示指针的步长 然而类型决定了步长整型 4个字节
//
//
//	printf("%p\n", pc);
//	printf("%p\n", pc+ 1);      //char类型就跳  1个字节
//
//	return 0;
//
//}

//===========================================================================================================================================================

//野指针
//就是指针指向的的位置是不可知的（随机的不正确的、没有明确限定的）
//1，局部指针变量未初始化，默认为随机值
//int main()
//{
//	int* p;   //局部变量不初始化，默认是随机值   //这样写是错误的写法
//	*p = 20;  //其指针就是 野指针
//	return 0;
//}

//2，指针越界访问
//int main()
//{
//
//	int arr[10] = { 0 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 12; i++)
//	{
//		*(p++)=i; //当指针指向的范围超出数组arr的范围时，p就是野指针
//				// 当i= 11 时 就产生了野指针
//
//	}
//	return 0;
//}

//3指针指向的空间释放
//int* test() 
//{
//	int a = 10;
//	return &a;  //假设放回 0x11223344
//}
//int main()
//{
//	int* p = test();  //当程序结束后 接受返回值 0x11223344
//	//如果写出 *p = 20 就出错了 *p 成为了野指针
//	
//	return 0;
//}

//如何规避野指针问题
//1.指针初始化；
//2.小心指针越界
//3.指针指向空间释放及时设 NULL
//4.指针使用之前检查有效性




//===================================================================================================================================


//指针运算

//指针+-整数

//int main()
//{
//	int arr[] = { 0,1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int* p = arr;
//
//	for (i = 0; i<sz ; i++)
//	{
//		printf("%d \n",*p);
//		p += 2;
//
//	}
//	return 0;
//}

//=====================================================================================================================================================

//指针 - 指针
//int main() 
//{
//
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%d\n",&arr[9] - &arr[0]);   // 指针减指针 得到指针和指针中间元素的个数 一定是大地址减小地址 否则得负数 只能是同一块空间中相减
//	return 0;
//}


//=============================================================================================================================================================
//指针和数组

//int my_strlen1(char* arr)   // 原始方法
//{
//	int count = 0;
//	while (1)
//	{
//		if (*arr != '\0')
//		{
//			count++;
//			arr ++;
//		}
//		else
//			break;
//	}
//	return count;
//}
//int my_strlen2(char* arr)           //利用指针的移动求字符串的大小
//{
//	char* start = arr;
//	char* end = arr;
//	while (*end != '\0')
//	{
//		end++;
//	}
//	return end - start;     //返回 指针减法求中间个数
//}
//int main()
//{
//	char arr[] = "454876132122";
//	int len1 = my_strlen1(arr);
//	int len2 = my_strlen2(arr);
//	printf("%d\n", len1);
//	printf("%d\n", len2);
//	return 0;
//}

//===========================================================================================================================================================
//二级指针
//
//int main()
//{
//	int a = 480;
//	int* pa = &a; 
//	int* * ppa = &pa;     //二级指针 ppa 存放一级指针的存储地址；
//	
//	int** * pppa = &ppa;
//
//	printf("%d",**ppa);
//	
//	return 0;
//}


//============================================================================================================================================================

//指针数组  --->数组  存放指针的数组
//数组指针  --->指针  
//
//int main()          //指针数组
//{
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	int i;
//	//指针数组存放数组 --> 存放指针
//	int* arr[] = { &a, &b, &c };
//	for (i = 0; i < 3; i++)
//	{
//		printf("%d\n",*(arr[i]));
//
//	}
//	return 0;
//}

//=============================================================================================================================================================

//作业  创建一个整型数组，完成对整型数组的操作
//1、实现函数 init()初始化数组为全零
//2、实现print()打印数组的每个元素
//3、实现reverse()函数完成数组元素的逆置

// void init(int arr[],int sz) 
//{
//	 int i = 0;
//	 for (i = 0; i < sz; i++) 
//	 {
//		 arr[i] = 0; 
//	 }
//}
// void print(int arr[],int sz)
// {
//	 int i = 0;
//	 for (i = 0; i < sz; i++)
//	 {
//		 printf("%d ", arr[i]);
//	 }
// }
// void reverse(int arr[],int sz) 
// {
//	 int left = 0;
//	 int right = sz-1;
//	 int tmp = 0;
//	 while (left < right)
//	 {
//		 tmp = arr[left];
//		 arr[left] = arr[right];
//		 arr[right] = tmp;
//		 left++;
//		 right--;
//	 }	 	 
// }
//
//int main()
//{
//	int arr[] = { 0,2,1,3,5,4,6,7,9,8,7};
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	
//	printf("\n");
//	print(arr,sz);           //打印函数
//	reverse(arr,sz);		//翻转函数
//	printf("\n");
//	print(arr, sz);
//	init(arr,sz);           //初始化函数
//	printf("\n");
//	print(arr, sz);
//
//	return 0;
//}

//====================================================================================================================================================
//交换数组A 与数组B 的内容 两个数组一样大
//void sw(int arrA[],int arrB[], int sz)
//{
//	int j = 0;
//	int tmp = 0;
//	for (j=0;j<=sz;j++) 
//	{
//		tmp = arrA[j];
//		arrA[j] = arrB[j];
//		arrB[j] = tmp;
//	}
//}
//
//void print(int arrA[], int arrB[],int sz1,int sz2)
//{
//	int i = 0;
//	for (i = 0; i < sz1; i++)
//	{
//		printf("%d ", arrA[i]);		
//	}
//	
//	printf("\n");
//	
//	for (i = 0; i < sz2; i++)
//	{
//		printf("%d ", arrB[i]);
//	}
//	printf("\n");
//}
//
//int main()
//{
//	int arrA[10] = { 4,5,6,7,8,9,1,2,3,0 };
//	int arrB[10] = { 14,15,16,17,18,19,11,12,13,10 };
//
//	int sz1 = sizeof(arrA) / sizeof(arrA[0]);
//	int sz2 = sizeof(arrB) / sizeof(arrB[0]);
//
//	print(arrA, arrB, sz1, sz2);
//
//	if (sz1 == sz2)
//	{
//		sw(arrA, arrB, sz1);
//		printf("交换的结果是\n");
//		print(arrA, arrB, sz1, sz2);
//	}
//	return 0;
//}

//========================================================================================================================================================
//统计二进制位中的1的个数
//
//int count_bit(unsigned int i)    //针对负数    方法1
//{ 
//	int count = 0;
//	while (i)
//	{
//		
//		if (i % 2 == 1)
//		{
//			count++;
//		}
//		i = i / 2;
//	}
//	return count;
//}
//
//int count_bit1(int i)  //方法2
//{
//	int n = 0;
//	int count2= 0;
//	
//	for(n= 0;n<32;n++)
//	{
//		if ((  (i >> n)& 1) == 1)
//		{
//			count2++;
//		}
//	}
//
//	return count2;
//}
//
//
//
//int count_bit2(int i)  //方法3       最精简的算法
//{
//	
//	int count= 0;
//	while (i)
//	{
//
//		i = i & (i - 1);
//		count++;
//
//	}
//	
//	return count;
//}
//
//int main()        //一个数在内存的储蓄是以补码的形式存储  所以求得是补码 中1的个数
//{
//	int i = 0;
//	scanf("%d",&i);
//
//	int sum1 = count_bit(i);
//	int sum2 = count_bit1(i);
//	int sum3 = count_bit2(i);
//
//	printf("%d\n", sum1);
//	printf("%d\n", sum2);
//	printf("%d\n", sum3);
//	return 0;
//}


//========================================================================================================================================================
//求二进制位中不同位的个数
//int main()  
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	int count = 0;
//
//	scanf("%d %d",&a,&b);
//	c = a ^ b;                  //异或后相异出1
//	while (c) 
//	{
//		c = c & (c - 1);       //统计二进制位中的 1 的个数
//		count++;
//	}
//	printf("不同位的个数为%d", count);
//	return 0;
//}



//========================================================================================================================================================
//交换二进制位的奇数位和偶数位 获取一个整数二进制序列中所有的偶位和奇数位，分别打印出二进制序列

//void print_odd(int m)   //打印奇数位  从高位开始排列 
//{
//	int n = 0;
//
//	printf("打印奇数位");
//	for (n=30;n>=0;n-=2) //打印奇数位
//	{
//		printf("%d",(m>>n)&1);
//	}
//	printf("\n");
//}
//
//
//void print_even(int m)
//{
//	int n = 0;
//	printf("打印偶数位");
//	for (n = 31; n >= 1; n -= 2) //打印偶数数位
//	{
//		printf("%d", (m >> n) & 1);
//	}
//	printf("\n");
//}
//
//int main()
//
//{
//	int m = 0;
//	scanf("%d",&m);
//	print_even(m);
//	print_odd( m)
//	return 0;
//}


//=============================================================================================================================================================
//实现一个函数 打印乘法口诀表 口诀表的行数和列数自己指定 如输入9 打印9*9乘法表 输入12打印12*12乘法表
// void print_table(int n)
// {
//	 int i = 0;
//	 int j = 0;
//	 for (i = 1; i <= n; i++)
//	 {
//		 for (j = 1; j <= i; j++)
//		 {
//			 printf("%3d*%3d=%3d   ", i, j, j * i);
//			
//		 }
//		 printf("\n");
//	 }
//}
//
//int main()
//{
//	int n = 0;
//	scanf("%d",&n);
//	print_table(n);
//	return 0;
//}
//===========================================================================================================================================================

//字符串逆序（递归实现）
//编写一个函数 reverse_string() (递归实现)
//将参数字符串中的字符反向排列  不能使用字符串的操作函数


//void reverse_string1(char parr[] ,int sz)  //方法一 
//{
//	int left = 0;
//	int right = sz-2;
//	while (left < right)
//	{
//		int tmp = 0;
//		tmp = parr[left];
//		parr[left]  = parr[right];
//		parr[right] = tmp;
//		left++;
//		right--;
//	}
//}
//void reverse_string2(char arr[],int sz)              //复杂的递归  22.作业讲解（2）片段4-0s
//{
//	
//
//
//
//int main()
//{
//	char arr[] = "1264479546";
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	printf("%s\n", arr);
//	reverse_string1(arr,sz);
//	printf("%s\n", arr);
//
//	reverse_string2(arr,sz);
//	printf("%s\n", arr);
//	return  0;
//}

//==============================================================================================================================================================
//写一个递归函数Digitsum(n),输入一个非负数 返回他们的数字之和
////
//int Digitsum(unsigned int num)
//{
//	int sum = 0;
//	if (num > 9)
//	{
//		return Digitsum(num / 10) + num % 10;
//	}
//	else
//	{
//		return num;
//	}
//}
//int main() 
//{
//	unsigned int num = 0;
//	scanf("%d", &num);
//	int ret = Digitsum(num);
//	printf("%d",ret);
//	
//	return 0;
//}

//======================================================================================================================================================================
//#include <math.h>
//int main()  //求n 的k次方  //1利用库函数方式解决
//{
//
//	int n = 0;
//	int k = 0;
//	printf("求n的k次方\n");
//	printf("请输入n = ");
//	scanf("%d",&n);
//	printf("请输入k = ");
//	scanf("%d",&k);
//
//	int ret  = pow((double)n,(double)k);
//	printf("n的k次方结果为 %d",ret);
//	return 0;
//}
//==================================================================================================================================================
//double Pow(int n,int k)
//{ 
//	if (k < 0) 
//	{
//		return (1.0 /( Pow(n,-k)));
//	}
//	else if (k == 0)
//		return 1;
//	else
//		return n * Pow(n, k - 1);
//	
//}
//
//int main()                                   //利用递归求n的k次方
//{
//
//		int n = 0;
//		int k = 0;
//		printf("求n的k次方\n");
//		printf("请输入n = ");
//		scanf("%d",&n);
//		printf("请输入k = ");
//		scanf("%d",&k);
//	
//		double ret  = Pow(n,k);
//		printf("n的k次方结果为 %lf",ret);
//		return 0;
//	
//}


//===============================================================================================================================================================






















